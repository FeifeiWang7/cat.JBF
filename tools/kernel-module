Kernel modules are often used for detachable devices, e.g., USB devices. It is also used for distributions who want to provide a kernel to their users regardless of the hardware these users own: during the boot-up sequence, the distribution loads the modules needed to support the hardware found and leave all other modules untouched.

The modules are read from somewhere: the driver for the disk cannot be put in a module and store that module on disk - the Linux kernel doesn't know what a disk is at that point. Similarly, the support for a particular file system, e.g., ext3, cannot be put in a module and store that module on an ext3 file system.

To be able to use kernel modules even though they might be required to access devices such as disks, you can create an intermediate root disk (initial root disk or initrd or initial ram file system or initramfs). This contains the modules that might be needed in order to successfully boot the system. Support for the initrd or initramfs format is built in-kernel (in-kernel means that support is not built as a kernel module but immediately made part of the Linux kernel image loaded by the boot loader).

The boot loader itself is responsible for placing the initrd or initramfs in memory and informing the Linux kernel where the initial root disk/file system can be found.

lsmod lists the currently loaded modules,, the size it takes in memory and how many and what other modules use it.

rmmod XXX removes a load module. Before do this, make sure that the module is not used by other modules.

modprobe XXX load a module in memory. 

modinfo XXX displays information about a module, e.g., what parameters can be added after modprobe. One example is modprobe XXX nodrop=1

----- Loading Modules -----
By default, Linux will load the modules needed by the system. It relies on hardware detection (modern hardware always exposes information about itself on a standardized manner) combined with the drivers of the kernel modules, which describe for which hardware they are made (and which other modules they require). What happens then is that udev gets informed by the Linux kernel about new hardware being detected. Udev then triggers a modprobe for that hardware, and based on the module information, modprobe knows which module to load.

The module information is generated by depmod when kernel modules are installed (copied) to a system. That's a "nice-to-know" item, because it will happen transparently for the user (users never need to run depmod themselves).

However, not all drivers know up-front which hardware they support (some hardware doesn't expose this information) or they collide with other drivers and, as a result, a system is configured not to autoload any module for that hardware. When in such a situation, the system still can automatically load a particular kernel module at boot time if users add the kernel module name to /etc/conf.d/modules. The file is self-explanatory, e.g., an example for auto-loading the ipw2200 module is adding 'modules="ipw2200"' to the file.

The system can automatically load a particular module. To accomplish this, add the kernel module name as a blacklist inside /etc/modprobe.d/blacklist.conf, e.g., 'blacklist uvcvideo'.

Blacklisting a module doesn't mean that the module cannot be loaded any more. It means that the automated load, based on the hardware information, is disabled. In other words, the link between a hardware device id and the module is blacklisted. A manual modprobe will still do the trick, and if the hardware isn't managed by another module yet, then this module will handle the hardware device.

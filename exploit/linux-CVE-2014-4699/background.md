From: https://hashcrack.org/page?n=21072014

The bug is how the SYSRET instruction is used by 64-bit kernels in the syscall exit path.

Compared to IRET, SYSRET does not restore all regular registers, segment registers or reflags, so it is faster than IRET.

SYSRET does the following things:

  * Load the instruction pointer (%rip) from %rcx
  * Change code segment selector to guest mode (this effectively changes the privilege level)
  
A general protection fault (#GP) is triggered, if a non-canonical memory address (invalid address in 64 bit system) ends up in %rcx upon executing the SYSRET instruction (since SYSRET loads %rip from %rcx). The #GP fault is thrown in privileged mode (ring0). This also means that the current %rsp value is used in handling the #GP! Since SYSRET does not restore the %rsp, the kernel has to perform this operation prior to executing SYSRET. By the time the #GP happens, the kernel would have already restored the %rsp value from the user-space %rsp. In summay, this means that if we can trigger #GP in SYSRET

 * #GP will execute in privileged mode
 * #GP will use the stack pointer supplied by us from user-space

How to trigger the #GP fault in the first place?

The %rip address loaded from %rcx would always be canonical. That's where ptrace comes into play.
Debuggers can stop a running process and let users change register values on-the-fly. Using ptrace we can change %rip and %rsp to arbitrary values. Most ptrace paths go via the interface that catches the process using the signal handler which always returns with IRET. However, there are a few paths that can get caught with ptrace_event() instead of the signal path. Refer to the PoC code for an example of using fork() with ptrace to force such a path.





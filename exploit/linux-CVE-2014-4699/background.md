From: https://hashcrack.org/page?n=21072014

The bug is how the SYSRET instruction is used by 64-bit kernels in the syscall exit path.

Compared to IRET, SYSRET does not restore all regular registers, segment registers or reflags, so it is faster than IRET.

SYSRET does the following things:

  * Load the instruction pointer (%rip) from %rcx
  
  * Change code segment selector to guest mode (this effectively changes the privilege level)
  
A general protection fault (#GP) is triggered, if a non-canonical memory address ends up in %rcx upon executing the SYSRET instruction (since SYSRET loads %rip from %rcx). The #GP fault is thrown in privileged mode (ring0). This also means that the current %rsp value is used in handling the #GP! Since SYSRET does not restore the %rsp, the kernel has to perform this operation prior to executing SYSRET. By the time the #GP happens, the kernel would have already restored the %rsp value from the user-space %rsp. In summay, this means that if we can trigger #GP in SYSRET

 * #GP will execute in privileged mode
 * #GP will use the stack pointer supplied by us from user-space
